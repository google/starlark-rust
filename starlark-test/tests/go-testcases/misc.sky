# Miscellaneous tests of Skylark evaluation.
# This is a "chunked" file: each "---" effectively starts a new file.

# TODO(adonovan): move these tests into more appropriate files.
# TODO(adonovan): test coverage:
# - stmts: pass; if cond fail; += and failures;
#    for x fail; for x not iterable; for can't assign; for
#    error in loop body
# - subassign fail
# - x[i]=x fail in both operands; frozen x; list index not int; boundscheck
# - x.f = ...
# - failure in list expr [...]; tuple expr; dict expr (bad key)
# - cond expr semantics; failures
# - x[i] failures in both args; dict and iterator key and range checks;
#   unhandled operand types
# - +: list/list, int/int, string/string, tuple+tuple, dict/dict;
# - * and ** calls: various errors
# - call of non-function
# - slice x[ijk]
# - comprehension: unhashable dict key;
#   scope of vars (local and toplevel); noniterable for clause
# - unknown unary op
# - ordering of values
# - freeze, transitivity of its effect.
# - add an application-defined type to the environment so we can test it.
# - even more:
#
# eval
#   pass statement
#   assign to tuple l-value -- illegal
#   assign to list l-value -- illegal
#   assign to field
#   tuple + tuple
#   call with *args, **kwargs
#   slice with step
#   tuple slice
#   interpolate with %c, %%

def lam(): None

# Ordered comparisons require values of the same type.
None < False  ###  compare not supported for types NoneType and bool
---
False < list  ###  compare not supported for types bool and function
---
list < {}     ###  compare not supported for types function and dict
---
0 < []        ###  compare not supported for types int and list
---
[] < ""       ###  compare not supported for types list and str
---
"" < ()       ###  compare not supported for types string and tuple

---
# cyclic data structures

cyclic = [1, 2, 3] # list cycle
cyclic[1] = cyclic
---
cyclic2 = [1, 2, 3]
cyclic2[1] = cyclic2
---

cyclic3 = [1, [2, 3]] # list-list cycle
cyclic3[1][0] = cyclic3
---
cyclic4 = {"x": 1}
cyclic4["x"] = cyclic4
---
cyclic5 = [0, {"x": 1}] # list-dict cycle
cyclic5[1]["x"] = cyclic5
---
cyclic6 = [0, {"x": 1}]
cyclic6[1]["x"] = cyclic6
---
# was a parse error:
assert_eq(("ababab"[2:]).replace("b", "c"), "acac")
assert_eq("ababab"[2:].replace("b", "c"), "acac")

# test parsing of line continuation, at toplevel and in expression.
three = 1 + \
  2
assert_eq(1 + \
  2, three)

---
# A regression test for error position information.

_ = {}.get(1, default=2) ### Extraneous parameter
